{
  "_args": [
    [
      {
        "raw": "tree-kit@^0.5.26",
        "scope": null,
        "escapedName": "tree-kit",
        "name": "tree-kit",
        "rawSpec": "^0.5.26",
        "spec": ">=0.5.26 <0.6.0",
        "type": "range"
      },
      "/Users/panagiotis/Desktop/nextcommerce database migration script/node_modules/async-kit"
    ]
  ],
  "_from": "tree-kit@>=0.5.26 <0.6.0",
  "_id": "tree-kit@0.5.26",
  "_inCache": true,
  "_location": "/tree-kit",
  "_nodeVersion": "4.4.7",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/tree-kit-0.5.26.tgz_1468416192589_0.9128831552807242"
  },
  "_npmUser": {
    "name": "cronvel",
    "email": "cedric.ronvel@gmail.com"
  },
  "_npmVersion": "2.15.8",
  "_phantomChildren": {},
  "_requested": {
    "raw": "tree-kit@^0.5.26",
    "scope": null,
    "escapedName": "tree-kit",
    "name": "tree-kit",
    "rawSpec": "^0.5.26",
    "spec": ">=0.5.26 <0.6.0",
    "type": "range"
  },
  "_requiredBy": [
    "/async-kit"
  ],
  "_resolved": "http://registry.npmjs.org/tree-kit/-/tree-kit-0.5.26.tgz",
  "_shasum": "8571c86fa24d1db754e5b0cb3a7e09f41e74a8df",
  "_shrinkwrap": null,
  "_spec": "tree-kit@^0.5.26",
  "_where": "/Users/panagiotis/Desktop/nextcommerce database migration script/node_modules/async-kit",
  "author": {
    "name": "Cédric Ronvel"
  },
  "bugs": {
    "url": "https://github.com/cronvel/tree-kit/issues"
  },
  "copyright": {
    "title": "Tree Kit",
    "years": [
      2014,
      2016
    ],
    "owner": "Cédric Ronvel"
  },
  "dependencies": {},
  "description": "Tree utilities which provides a full-featured extend and object-cloning facility, and various tools to deal with nested object structures.",
  "devDependencies": {
    "browserify": "^13.0.1",
    "expect.js": "^0.3.1",
    "jshint": "^2.5.6",
    "mocha": "^2.2.5",
    "uglify-js": "^2.7.0"
  },
  "directories": {
    "test": "test",
    "bench": "bench"
  },
  "dist": {
    "shasum": "8571c86fa24d1db754e5b0cb3a7e09f41e74a8df",
    "tarball": "https://registry.npmjs.org/tree-kit/-/tree-kit-0.5.26.tgz"
  },
  "gitHead": "27673d9d51f3f9614cf06fe5a9f5ed54af8926d1",
  "homepage": "https://github.com/cronvel/tree-kit#readme",
  "keywords": [
    "tree",
    "extend",
    "clone",
    "prototype",
    "inherit",
    "deep",
    "diff",
    "mask"
  ],
  "license": "MIT",
  "main": "lib/tree.js",
  "maintainers": [
    {
      "name": "cronvel",
      "email": "cedric.ronvel@gmail.com"
    }
  ],
  "name": "tree-kit",
  "optionalDependencies": {},
  "readme": "\n\n# Tree Kit\n\nThis lib is a toolbox that provide functions to operate with nested `Object` structure.\nIt features the best `.extend()` method, providing dozen of options that all others libs miss.\n\n* License: MIT\n* Current status: release candidate\n* Platform: Node.js only (browser support is planned)\n\nSome tutorials are available at [blog.soulserv.net/tag/tree-kit](http://blog.soulserv.net/tag/tree-kit/).\n\n\n\n# Install\n\nUse Node Package Manager:\n\n    npm install tree-kit\n\n\n\n# Library references\n\n* [.extend()](#ref.extend): full-featured extend facility, copy, clone, extend\n* [.clone()](#ref.clone): clone any object\n* [.diff()](#ref.diff): report differences between two objects\n\n\n\nIn all examples below, it is assumed that you have required the lib into the `tree` variable:\n```js\nvar tree = require( 'tree-kit' ) ;\n```\n\n\n\n<a name=\"ref.extend\"></a>\n## .extend( options , target , source1 , [source2] , [...] )\n\n* options `Object` extend options, it supports the properties:\n\t* own `boolean` only copy enumerable own properties from the sources\n    * nonEnum `boolean` copy non-enumerable properties as well, works only with own:true\n    * descriptor `boolean` preserve property's descriptor (i.e. writable, enumerable, configurable, get & set)\n\t* deep `boolean` perform a deep (recursive) extend\n\t* circular `boolean` (default to false) if true then circular references are checked and each identical objects are reconnected\n\t\t(referenced), if false then nested object are blindly cloned\n\t* maxDepth `integer` used in conjunction with deep, when the max depth is reached an exception is raised, it defaults to 100\n\t\twhen the 'circular' option is off, or defaults to null if 'circular' is on\n\t* move `boolean` move properties from the sources object to the target object (delete properties from the sources object)\n\t* preserve `boolean` existing properties in the target object will not be overwritten\n\t* nofunc `boolean` skip properties that are functions\n\t* deepFunc `boolean` in conjunction with 'deep', this will process sources functions like objects rather than\n\t  copying/referencing them directly into the source (default behaviour), thus, the result will not be a function,\n\t  it forces 'deep' options\n\t* proto `boolean` alter the target's prototype so that it matches the source's prototype.\n\t  It forces option 'own'. Specifying multiple sources does not make sens here.\n\t* inherit `boolean` make the target inherit from the source (the target's prototype will be the source itself, not its prototype).\n\t  It forces option 'own' and disable 'proto'. Specifying multiple sources does not make sens here.\n\t* skipRoot `boolean` prevent the prototype of the target **root** object from mutation.\n\t  Only nested objects' prototype will be mutated.\n\t* flat `boolean|string` sources properties are copied in a way to produce a *flat* target, the target's key\n\t  is the full path (separated by '.') of the source's key, also if a string is provided it will be used as\n\t  the path separator\n\t* unflat `boolean|string` it is the opposite of 'flat': assuming that the sources are in the *flat* format,\n\t  it expands all flat properties -- whose name are path with '.' as the separator -- deeply into the target, \n\t  also if a string is provided it will be used as the path separator\n\t* deepFilter `Object` filter the recursiveness of the 'deep' option, filtered objects will be referenced\n\t  just the way it would be if the 'deep' option was turned off, objects are filtered based upon their\n\t  prototypes (only direct prototype match, for performance purpose the rest of the prototype chain will\n\t  not be checked)\n\t\t* blacklist `Array` list of black-listed prototype\n\t\t* whitelist `Array` list of white-listed prototype\n* target `Object` the target of the extend, properties will be copied to this object\n* source1 `Object` the source of the extend, properties will be copied from this object\n* ...\n\nThis is a full-featured *extend* of an object with one or more source object.\n\nIt is easily translated from jQuery-like *extend()*:\n* `extend( target , source )` translate into `tree.extend( null , target , source )`\n* `extend( true , target , source )` translate into `tree.extend( { deep: true } , target , source )`\n\nHowever, here we have full control over what will be extended and how.\n\n**All the options above are inactive by default**.\nYou can pass null as argument #0 to get the default behaviour (= all options are inactive).\nSo using the default behaviour, `tree.extend()` will copy all enumerable properties, and perform a shallow copy (a nested object\nis not cloned, it remains a reference of the original one).\n\nWith the *deep* option, a deep copy is performed, so nested object are cloned too.\n\nThe *own* option clone only owned properties from the sources, properties that are part of the source's prototype would not\nbe copied/cloned.\n\nThe *nonEnum* option will clone properties that are not enumerable.\n\nThe *descriptor* option will preserve property's descriptor, e.g. if the source property is not writable and not enumerable,\nso will be the copied property.\n\nIn case of a *getter* properties:\n\n* without the *descriptor* option, the getter function of the source object will be called, the return value will be put\n  into the target property (so it lose its getter/setter behaviour)\n* with the *descriptor* option, the getter & setter function of the source object will be copied (but not called) into the target\n  property: the getter/setter behaviour is preserved\n\nIf *circular* is on, the lib will detect when the source's data structure reuses the same object multiple time and will preserve it.\nWe can see this *circular* feature in action in [this example](#example.circular).\n\nMixing *inherit* and *deep* provides a nice multi-level inheritance.\n\nWith the *flat* option example:\n```js\nvar o = {\n\tone: 1,\n\tsub: {\n\t\ttwo: 2,\n\t\tthree: 3\n\t}\n} ;\n\nvar flatCopy = tree.extend( { flat: true } , {} , o ) ;\n```\n... it will produce:\n```js\n{\n\tone: 1,\n\t\"sub.two\": 2,\n\t\"sub.three\": 3\n}\n```\n\nBy the way, the *unflat* option does the opposite, and thus can reverse this back to the original form.\n\nThe *deepFilter* option is used when you do not want to clone some type of object.\nLet's say you want a deep copy except for `Buffer` objects, you simply want them to share the same reference:\n```js\nvar o = {\n\tone: '1' ,\n\tbuf: new Buffer( \"My buffer\" ) ,\n\tsubtree: {\n\t\ttwo: 2 ,\n\t\tthree: 'THREE'\n\t}\n} ;\n\n// either\nvar extended1 = tree.extend( { deep: true, deepFilter: { whitelist: [ Object.prototype ] } } , {} , o ) ;\n// or\nvar extended2 = tree.extend( { deep: true, deepFilter: { blacklist: [ Buffer.prototype ] } } , {} , o ) ;\n```\n\nDoing this, we have `o.buf === extended1.buf === extended2.buf`, and `o.subtree !== extended1.subtree !== extended2.subtree`.\n\n\n\n<a name=\"ref.clone\"></a>\n## .clone( original , [circular] )\n\n* original `Object` the source object to clone\n* circular `boolean` (default to false) if true then circular references are checked and each identical objects are reconnected\n\t(referenced), if false then nested object are blindly cloned\n\nIt returns a clone of the *original* object, providing the best object-cloning facility that this lib can offer.\n\nThe clone produced are perfect independant copy **in 99% of use case**, but there is one big limitation:\nmethod that access variables in the parent's scope.\n\nThe clone will share those variables with the *original* object, so they are not totally independant entity.\nDesign pattern using closure to emulate *private member* (e.g. the revealing pattern) can cause trouble.\n\nIf *circular* is on, the lib will detect when the source's data structure reuses the same object multiple time and will preserve it.\n\n<a name=\"example.circular\"></a>\nHere is an example of this *circular* feature:\n```js\nvar o = {\n\ta: 'a',\n\tsub: {\n\t\tb: 'b'\n\t},\n\tsub2: {\n\t\tc: 'c'\n\t}\n} ;\n\no.loop = o ;\no.sub.loop = o ;\no.subcopy = o.sub ;\no.sub.link = o.sub2 ;\no.sub2.link = o.sub ;\n\nvar c = tree.clone( o , true ) ;\n\nexpect( c.loop ).to.be( c ) ;\nexpect( c.sub ).to.be( c.subcopy ) ;\nexpect( c.sub.loop ).to.be( c ) ;\nexpect( c.subcopy.loop ).to.be( c ) ;\nexpect( c.sub.link ).to.be( c.sub2 ) ;\nexpect( c.sub2.link ).to.be( c.sub ) ;\n```\n\n... without *circular* on, the `clone()` method would run forever, creating a new object independant nested object each time\nit reaches the *loop* property.\nWe can see that the *subcopy* property remains a reference of *sub* even in the clone, thanks to the *circular* option.\n\nHowever, if we are sure that there isn't multiple reference to the same object or circular references, we can gain a lot of\nperformances by leaving that options off.\nIt can save a lot of `.indexOf()` call on big data structure.\n\nThis method does not uses `extend()` anymore like in version 0.3.x, it now uses its own optimized code.\nHowever it is equivalent to an `extend()` with those options turned on: *deep, own, nonEnum, descriptor & proto*.\nIf *circular* is on, it has the same effect than the `extend()`'s *circular* option.\n\n**Also please note that design pattern emulating private members using a closure's scope cannot be truly cloned**\n(e.g. the *revealing pattern*).\nThis is not possible to mutate a function's scope.\nSo the clone's methods will continue to inherit the parent's scope of the original function.\n\n\n\n<a name=\"ref.diff\"></a>\n## .diff( left , right , [options] )\n\n* left `Object` the left-hand side object structure\n* right `Object` the right-hand side object structure\n* options `Object` containing options, it supports:\n\t* path `string` the initial path, default: empty string\n\t* pathSeparator `string` the path separator, default: '.'\n\nThis tool reports diff between a left-hand side and right-hand side object structure.\nIt returns an object, each key is a path where a difference is reported, the value being an object containing (again) the path\nand a human-readable message.\n\nSee this example:\n```js\nvar left = {\n\ta: 'a',\n\tb: 2,\n\tc: 'three',\n\tsub: {\n\t\te: 5,\n\t\tf: 'six',\n\t}\n} ;\n\nvar right = {\n\tb: 2,\n\tc: 3,\n\td: 'dee',\n\tsub: {\n\t\te: 5,\n\t\tf: 6,\n\t}\n} ;\n\nconsole.log( tree.diff( a , b ) ) ;\n```\nIt will output:\n```js\n{ '.a': { path: '.a', message: 'does not exist in right-hand side' },\n  '.c': { path: '.c', message: 'different typeof: string - number' },\n  '.sub.f': { path: '.sub.f', message: 'different typeof: string - number' },\n  '.d': { path: '.d', message: 'does not exist in left-hand side' } }\n```\n\n\n\n\n\nFull BDD spec generated by Mocha:\n\n\n# TOC\n   - [clone()](#clone)\n   - [Diff](#diff)\n   - [extend()](#extend)\n   - [defineLazyProperty()](#definelazyproperty)\n   - [Masks](#masks)\n   - [Inverse masks](#inverse-masks)\n   - [Tree's path on objects](#trees-path-on-objects)\n   - [Tree's path on arrays](#trees-path-on-arrays)\n   - [Tree's path on mixed object and arrays](#trees-path-on-mixed-object-and-arrays)\n   - [Inheritance, using Object.create( tree.path.prototype )](#inheritance-using-objectcreate-treepathprototype-)\n   - [Tree's array path on objects](#trees-array-path-on-objects)\n<a name=\"\"></a>\n \n<a name=\"clone\"></a>\n# clone()\nbasic incomplete test.\n\n```js\nvar proto = {\n\tproto1: 'proto1' ,\n\tproto2: 'proto2' ,\n\thello: function() { console.log( \"Hello!\" ) ; }\n} ;\n\nvar o = Object.create( proto ) ;\n\no.own1 = 'own1' ;\no.own2 = 'own2' ;\no.nested = { a: 1 , b: 2 } ;\n\nvar getter = function() { return 5 ; } ;\nvar setter = function( value ) {} ;\n\nObject.defineProperties( o , {\n\tnonEnum1: { value: 'nonEnum1' } ,\n\tnonEnum2: { value: 'nonEnum2' , writable: true } ,\n\tnonEnum3: { value: 'nonEnum3' , configurable: true } ,\n\tnonEnumNested: { value: { c: 3 , d: 4 } } ,\n\tgetter: { get: getter } ,\n\tgetterAndSetter: { get: getter , set: setter }\n} ) ;\n\nvar i , r ;\n\n\n// Basic tests with and without circular checks\nfor ( i = 0 ; i <= 1 ; i ++ )\n{\n\tif ( i === 0 ) { r = tree.clone( o ) ;}\n\telse { r = tree.clone( o , true ) ; }\n\t\n\texpect( Object.getOwnPropertyNames( r ) ).to.eql( [ 'own1' , 'own2' , 'nested' , 'nonEnum1' , 'nonEnum2' , 'nonEnum3' , 'nonEnumNested' , 'getter' , 'getterAndSetter' ] ) ;\n\texpect( Object.getOwnPropertyDescriptor( r , 'own1' ) ).to.eql( { value: 'own1' , enumerable: true , writable: true , configurable: true } ) ;\n\texpect( Object.getOwnPropertyDescriptor( r , 'own2' ) ).to.eql( { value: 'own2' , enumerable: true , writable: true , configurable: true } ) ;\n\texpect( r.nested ).not.to.be( o.nested ) ;\n\texpect( r.nested ).to.eql( o.nested ) ;\n\texpect( Object.getOwnPropertyDescriptor( r , 'nested' ) ).to.eql( { value: o.nested , enumerable: true , writable: true , configurable: true } ) ;\n\texpect( Object.getOwnPropertyDescriptor( r , 'nonEnum1' ) ).to.eql( { value: 'nonEnum1' , enumerable: false , writable: false , configurable: false } ) ;\n\texpect( Object.getOwnPropertyDescriptor( r , 'nonEnum2' ) ).to.eql( { value: 'nonEnum2' , enumerable: false , writable: true , configurable: false } ) ;\n\texpect( Object.getOwnPropertyDescriptor( r , 'nonEnum3' ) ).to.eql( { value: 'nonEnum3' , enumerable: false , writable: false , configurable: true } ) ;\n\texpect( r.nonEnumNested ).not.to.be( o.nonEnumNested ) ;\n\texpect( r.nonEnumNested ).to.eql( o.nonEnumNested ) ;\n\texpect( Object.getOwnPropertyDescriptor( r , 'nonEnumNested' ) ).to.eql( { value: o.nonEnumNested , enumerable: false , writable: false , configurable: false } ) ;\n\texpect( Object.getOwnPropertyDescriptor( r , 'getter' ) ).to.eql( { get: getter , set: undefined , enumerable: false , configurable: false } ) ;\n\texpect( Object.getOwnPropertyDescriptor( r , 'getterAndSetter' ) ).to.eql( { get: getter , set: setter , enumerable: false , configurable: false } ) ;\n\t\n\texpect( r.__proto__ ).to.equal( proto ) ;\t// jshint ignore:line\n\texpect( r.proto1 ).to.be( 'proto1' ) ;\n\texpect( r.proto2 ).to.be( 'proto2' ) ;\n\texpect( typeof r.hello ).to.equal( 'function' ) ;\n}\n```\n\ncircular references test.\n\n```js\nvar c , o = {\n\ta: 'a',\n\tsub: {\n\t\tb: 'b'\n\t},\n\tsub2: {\n\t\tc: 'c'\n\t}\n} ;\n\no.loop = o ;\no.sub.loop = o ;\no.subcopy = o.sub ;\no.sub.link = o.sub2 ;\no.sub2.link = o.sub ;\n\n\nc = tree.clone( o , true ) ;\n\nexpect( c.loop ).to.be( c ) ;\nexpect( c.sub ).to.be( c.subcopy ) ;\nexpect( c.sub.loop ).to.be( c ) ;\nexpect( c.subcopy.loop ).to.be( c ) ;\nexpect( c.sub.link ).to.be( c.sub2 ) ;\nexpect( c.sub2.link ).to.be( c.sub ) ;\n```\n\ncloning an array.\n\n```js\nvar a , c ;\n\na = [ 'one' , 'two' , 'three' ] ;\nc = tree.clone( a ) ;\nexpect( c ).to.eql( a ) ;\nexpect( Array.isArray( c ) ).to.be.ok() ;\n\na = [ 'one' , [ 'two' , 'three' ] ] ;\nc = tree.clone( a ) ;\nexpect( c ).to.eql( a ) ;\nexpect( Array.isArray( c ) ).to.be.ok() ;\nexpect( Array.isArray( c[ 1 ] ) ).to.be.ok() ;\n```\n\n<a name=\"diff\"></a>\n# Diff\nshould return an array of differences for two objects without nested object.\n\n```js\nvar a = {\n\ta: 'a',\n\tb: 2,\n\tc: 'three'\n} ;\n\nvar b = {\n\tb: 2,\n\tc: 3,\n\td: 'dee'\n} ;\n\nvar diff = tree.diff( a , b ) ;\n\n//console.log( JSON.stringify( diff , null , '  ' ) ) ;\nexpect( diff ).not.to.be( null ) ;\nexpect( diff ).to.only.have.keys( '.a', '.c', '.d' ) ;\n```\n\nshould return an array of differences for two objects with nested objects.\n\n```js\nvar a = {\n\ta: 'a',\n\tb: 2,\n\tc: 'three',\n\tsub: {\n\t\te: 5,\n\t\tf: 'six',\n\t\tsubsub: {\n\t\t\tg: 'gee',\n\t\t\th: 'h'\n\t\t}\n\t},\n\tsuba: {\n\t\tj: 'djay'\n\t}\n} ;\n\nvar b = {\n\tb: 2,\n\tc: 3,\n\td: 'dee',\n\tsub: {\n\t\te: 5,\n\t\tf: 6,\n\t\tsubsub: {\n\t\t\tg: 'gee',\n\t\t\ti: 'I'\n\t\t}\n\t},\n\tsubb: {\n\t\tk: 'k'\n\t}\n} ;\n\nvar diff = tree.diff( a , b ) ;\n\n//console.log( JSON.stringify( diff , null , '  ' ) ) ;\nexpect( diff ).not.to.be( null ) ;\nexpect( diff ).to.only.have.keys( '.a', '.c', '.d', '.sub.f', '.sub.subsub.h', '.sub.subsub.i', '.suba', '.subb' ) ;\n```\n\n<a name=\"extend\"></a>\n# extend()\nshould extend correctly an empty Object with a flat Object without depth (with or without the 'deep' option).\n\n```js\nvar copy ;\n\nvar expected = {\n\td : 4 ,\n\te : undefined ,\n\tf : 3.14 ,\n\tg : 6 ,\n\th : [] ,\n\ti : 'iii'\n} ;\n\ncopy = extend( { deep: true } , {} , input.subtree.subtree ) ;\nexpect( extend( null , copy , input.subtree.subtree2 ) ).to.eql( expected ) ;\n\ncopy = extend( { deep: true } , {} , input.subtree.subtree ) ;\nexpect( extend( { deep: true } , copy , input.subtree.subtree2 ) ).to.eql( expected ) ;\n```\n\nshould extend an empty Object with a deep Object performing a SHALLOW copy, the result should be equal to the deep Object, nested object MUST be equal AND identical.\n\n```js\nvar copy = extend( null , {} , input.subtree ) ;\nexpect( copy ).to.eql( input.subtree ) ;\nexpect( copy ).not.to.equal( input.subtree ) ;\nexpect( copy.subtree2 ).to.equal( input.subtree.subtree2 ) ;\n```\n\nwith the 'deep' option should extend an empty Object with a deep Object performing a DEEP copy, the result should be equal to the deep Object, nested object MUST be equal BUT NOT identical.\n\n```js\nvar copy = extend( { deep: true } , {} , input.subtree ) ;\nexpect( copy ).to.eql( input.subtree ) ;\nexpect( copy ).not.to.equal( input.subtree ) ;\nexpect( copy.subtree2 ).not.to.equal( input.subtree.subtree2 ) ;\n```\n\nwith the 'deep' option, sources functions are still simply copied/referenced into target.\n\n```js\nvar copy = extend( { deep: true } , {} , input.subtreeWithFunction ) ;\n//console.log( copy ) ;\nexpect( copy ).to.eql( input.subtreeWithFunction ) ;\nexpect( copy ).not.to.equal( input.subtreeWithFunction ) ;\nexpect( copy.Func.prototype ).to.equal( input.subtreeWithFunction.Func.prototype ) ;\n```\n\nwith the 'deep' & 'deepFunc' options, sources functions are treated like regular objects, creating an object rather than a function in the target location, and performing a deep copy of them.\n\n```js\nvar copy = extend( { deep: true, deepFunc: true } , {} , input.subtreeWithFunction ) ;\nexpect( copy ).not.to.eql( input.subtreeWithFunction ) ;\nexpect( copy ).to.eql( { z: 'Zee' , Func: { prop: 'property' } } ) ;\n```\n\nshould extend (by default) properties of the prototype chain.\n\n```js\nvar proto = {\n\tproto1: 'proto1' ,\n\tproto2: 'proto2' ,\n} ;\n\nvar o = Object.create( proto ) ;\n\no.own1 = 'own1' ;\no.own2 = 'own2' ;\n\nexpect( extend( null , {} , o ) ).to.eql( {\n\tproto1: 'proto1' ,\n\tproto2: 'proto2' ,\n\town1: 'own1' ,\n\town2: 'own2'\n} ) ;\n\nexpect( extend( { deep: true } , {} , o ) ).to.eql( {\n\tproto1: 'proto1' ,\n\tproto2: 'proto2' ,\n\town1: 'own1' ,\n\town2: 'own2'\n} ) ;\n```\n\nwith the 'own' option, it should ONLY extend OWNED properties, non-enumerable properties and properties of the prototype chain are SKIPPED.\n\n```js\nvar proto = {\n\tproto1: 'proto1' ,\n\tproto2: 'proto2' ,\n} ;\n\nvar o = Object.create( proto ) ;\n\no.own1 = 'own1' ;\no.own2 = 'own2' ;\n\nObject.defineProperties( o , {\n\tnonEnum1: { value: 'nonEnum1' } ,\n\tnonEnum2: { value: 'nonEnum2' }\n} ) ;\n\nexpect( extend( { own: true } , {} , o ) ).to.eql( {\n\town1: 'own1' ,\n\town2: 'own2'\n} ) ;\n\nexpect( extend( { deep: true, own: true } , {} , o ) ).to.eql( {\n\town1: 'own1' ,\n\town2: 'own2'\n} ) ;\n```\n\nwith the 'own' & 'nonEnum' option, it should ONLY extend OWNED properties, enumerable or not, but properties of the prototype chain are SKIPPED.\n\n```js\nvar proto = {\n\tproto1: 'proto1' ,\n\tproto2: 'proto2' ,\n} ;\n\nvar o = Object.create( proto ) ;\n\no.own1 = 'own1' ;\no.own2 = 'own2' ;\n\nObject.defineProperties( o , {\n\tnonEnum1: { value: 'nonEnum1' } ,\n\tnonEnum2: { value: 'nonEnum2' }\n} ) ;\n\nexpect( extend( { own: true , nonEnum: true } , {} , o ) ).to.eql( {\n\town1: 'own1' ,\n\town2: 'own2' ,\n\tnonEnum1: 'nonEnum1' ,\n\tnonEnum2: 'nonEnum2'\n} ) ;\n\nexpect( extend( { deep: true, own: true , nonEnum: true } , {} , o ) ).to.eql( {\n\town1: 'own1' ,\n\town2: 'own2' ,\n\tnonEnum1: 'nonEnum1' ,\n\tnonEnum2: 'nonEnum2'\n} ) ;\n```\n\nwith the 'descriptor' option, it should preserve descriptor as well.\n\n```js\nvar r ;\n\nvar proto = {\n\tproto1: 'proto1' ,\n\tproto2: 'proto2' ,\n} ;\n\nvar o = Object.create( proto ) ;\n\no.own1 = 'own1' ;\no.own2 = 'own2' ;\no.nested = { a: 1 , b: 2 } ;\n\nvar getter = function() { return 5 ; } ;\nvar setter = function( value ) {} ;\n\nObject.defineProperties( o , {\n\tnonEnum1: { value: 'nonEnum1' } ,\n\tnonEnum2: { value: 'nonEnum2' , writable: true } ,\n\tnonEnum3: { value: 'nonEnum3' , configurable: true } ,\n\tnonEnumNested: { value: { c: 3 , d: 4 } } ,\n\tgetter: { get: getter } ,\n\tgetterAndSetter: { get: getter , set: setter }\n} ) ;\n\nr = extend( { own: true , nonEnum: true , descriptor: true } , {} , o ) ;\n\nexpect( Object.getOwnPropertyNames( r ) ).to.eql( [ 'own1' , 'own2' , 'nested' , 'nonEnum1' , 'nonEnum2' , 'nonEnum3' , 'nonEnumNested' , 'getter' , 'getterAndSetter' ] ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'own1' ) ).to.eql( { value: 'own1' , enumerable: true , writable: true , configurable: true } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'own2' ) ).to.eql( { value: 'own2' , enumerable: true , writable: true , configurable: true } ) ;\nexpect( r.nested ).to.be( o.nested ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'nested' ) ).to.eql( { value: o.nested , enumerable: true , writable: true , configurable: true } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'nonEnum1' ) ).to.eql( { value: 'nonEnum1' , enumerable: false , writable: false , configurable: false } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'nonEnum2' ) ).to.eql( { value: 'nonEnum2' , enumerable: false , writable: true , configurable: false } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'nonEnum3' ) ).to.eql( { value: 'nonEnum3' , enumerable: false , writable: false , configurable: true } ) ;\nexpect( r.nonEnumNested ).to.be( o.nonEnumNested ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'nonEnumNested' ) ).to.eql( { value: o.nonEnumNested , enumerable: false , writable: false , configurable: false } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'getter' ) ).to.eql( { get: getter , set: undefined , enumerable: false , configurable: false } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'getterAndSetter' ) ).to.eql( { get: getter , set: setter , enumerable: false , configurable: false } ) ;\n\nr = extend( { deep: true , own: true , nonEnum: true , descriptor: true } , {} , o ) ;\n\nexpect( Object.getOwnPropertyNames( r ) ).to.eql( [ 'own1' , 'own2' , 'nested' , 'nonEnum1' , 'nonEnum2' , 'nonEnum3' , 'nonEnumNested' , 'getter' , 'getterAndSetter' ] ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'own1' ) ).to.eql( { value: 'own1' , enumerable: true , writable: true , configurable: true } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'own2' ) ).to.eql( { value: 'own2' , enumerable: true , writable: true , configurable: true } ) ;\nexpect( r.nested ).not.to.be( o.nested ) ;\nexpect( r.nested ).to.eql( o.nested ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'nested' ) ).to.eql( { value: o.nested , enumerable: true , writable: true , configurable: true } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'nonEnum1' ) ).to.eql( { value: 'nonEnum1' , enumerable: false , writable: false , configurable: false } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'nonEnum2' ) ).to.eql( { value: 'nonEnum2' , enumerable: false , writable: true , configurable: false } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'nonEnum3' ) ).to.eql( { value: 'nonEnum3' , enumerable: false , writable: false , configurable: true } ) ;\nexpect( r.nonEnumNested ).not.to.be( o.nonEnumNested ) ;\nexpect( r.nonEnumNested ).to.eql( o.nonEnumNested ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'nonEnumNested' ) ).to.eql( { value: o.nonEnumNested , enumerable: false , writable: false , configurable: false } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'getter' ) ).to.eql( { get: getter , set: undefined , enumerable: false , configurable: false } ) ;\nexpect( Object.getOwnPropertyDescriptor( r , 'getterAndSetter' ) ).to.eql( { get: getter , set: setter , enumerable: false , configurable: false } ) ;\n```\n\nwith the 'deep' option should extend a deep Object into another deep Object correctly.\n\n```js\nvar copy ;\n\ncopy = extend( { deep: true } , {} , input.subtree ) ;\nexpect( extend( null , copy , input.anotherSubtree ) ).to.eql( {\n\ta : 'A' ,\n\tb : 2 ,\n\tsubtree: {\n\t\tl : '1one' ,\n\t\tm : false ,\n\t\tn : 'nay'\n\t} ,\n\tc : 'plusplus' ,\n\tsubtree2: {\n\t\tp : true ,\n\t\tq : [4,5,6] ,\n\t\tr : '2'\n\t} ,\n\tj : 'Djay' ,\n\tk : 'ok' ,\n\to : 'mg'\n} ) ;\n\ncopy = extend( { deep: true } , {} , input.subtree ) ;\nexpect( extend( { deep: true } , copy , input.anotherSubtree ) ).to.eql( {\n\ta : 'A' ,\n\tb : 2 ,\n\tsubtree: {\n\t\td : 4 ,\n\t\te : undefined ,\n\t\tf : 3.14 ,\n\t\tl : '1one' ,\n\t\tm : false ,\n\t\tn : 'nay'\n\t} ,\n\tc : 'plusplus' ,\n\tsubtree2: {\n\t\tg : 6 ,\n\t\th : [] ,\n\t\ti : 'iii',\n\t\tp : true ,\n\t\tq : [4,5,6] ,\n\t\tr : '2'\n\t} ,\n\tj : 'Djay' ,\n\tk : 'ok' ,\n\to : 'mg'\n} ) ;\n```\n\nwith the 'proto' option and a null (or falsy) target, it should create and return a new Object with the prototype of the source Object.\n\n```js\nvar e , o , proto ;\n\nproto = {\n\tproto1: 'proto1' ,\n\tproto2: 'proto2' ,\n\thello: function() { console.log( \"Hello!\" ) ; }\n} ;\n\no = Object.create( proto ) ;\no.own1 = 'own1' ;\no.own2 = 'own2' ;\n\ne = extend( { proto: true } , null , o ) ;\n\nexpect( e ).not.to.be( o ) ;\nexpect( e.__proto__ ).to.equal( proto ) ;\t// jshint ignore:line\nexpect( e ).to.eql( { own1: 'own1' , own2: 'own2' } ) ;\nexpect( e.proto1 ).to.be( 'proto1' ) ;\nexpect( e.proto2 ).to.be( 'proto2' ) ;\nexpect( typeof e.hello ).to.equal( 'function' ) ;\n```\n\nwith the 'proto' option should change the prototype of each target properties for the prototype of the related source properties, if 'deep' is enabled it does so recursively.\n\n```js\nvar e , o , proto1 , proto2 ;\n\nproto1 = {\n\tproto1: 'proto1' ,\n\thello: function() { console.log( \"Hello!\" ) ; }\n} ;\n\nproto2 = {\n\tproto2: 'proto2' ,\n\tworld: function() { console.log( \"World!\" ) ; }\n} ;\n\no = {\n\town1: 'own1' ,\n\town2: 'own2' ,\n\tembed1: Object.create( proto1 , { a: { value: 'a' , enumerable: true } } ) ,\n\tembed2: Object.create( proto2 , { b: { value: 'b' , enumerable: true } } )\n} ;\n\ne = extend( { proto: true } , {} , o ) ;\n\nexpect( e ).not.to.be( o ) ;\nexpect( e ).to.eql( {\n\town1: 'own1' ,\n\town2: 'own2' ,\n\tembed1: { a: 'a' } ,\n\tembed2: { b: 'b' }\n} ) ;\nexpect( e.embed1 ).to.be( o.embed1 ) ;\nexpect( e.embed2 ).to.be( o.embed2 ) ;\nexpect( e.embed1.proto1 ).to.be( 'proto1' ) ;\nexpect( e.embed2.proto2 ).to.be( 'proto2' ) ;\nexpect( typeof e.embed1.hello ).to.equal( 'function' ) ;\nexpect( typeof e.embed2.world ).to.equal( 'function' ) ;\n\n\ne = extend( { proto: true, deep: true } , {} , o ) ;\n\nexpect( e ).not.to.be( o ) ;\nexpect( e ).to.eql( {\n\town1: 'own1' ,\n\town2: 'own2' ,\n\tembed1: { a: 'a' } ,\n\tembed2: { b: 'b' }\n} ) ;\nexpect( e.embed1 ).not.to.be( o.embed1 ) ;\nexpect( e.embed2 ).not.to.be( o.embed2 ) ;\nexpect( e.embed1.proto1 ).to.be( 'proto1' ) ;\nexpect( e.embed2.proto2 ).to.be( 'proto2' ) ;\nexpect( typeof e.embed1.hello ).to.equal( 'function' ) ;\nexpect( typeof e.embed2.world ).to.equal( 'function' ) ;\n```\n\nwith 'nofunc' option should skip function.\n\n```js\nvar e , o , proto ;\n\nproto = {\n\tproto1: 'proto1' ,\n\tproto2: 'proto2' ,\n\thello: function() { console.log( \"Hello...\" ) ; }\n} ;\n\no = Object.create( proto ) ;\no.own1 = 'own1' ;\no.world = function() { console.log( \"world!!!\" ) ; } ;\no.own2 = 'own2' ;\n\n// default behaviour\ne = extend( { nofunc: true } , null , o ) ;\nexpect( e ).not.to.be( o ) ;\nexpect( e ).to.eql( { own1: 'own1' , own2: 'own2' , proto1: 'proto1' , proto2: 'proto2' } ) ;\n\n// with 'own'\ne = extend( { nofunc: true , own: true } , null , o ) ;\nexpect( e ).not.to.be( o ) ;\nexpect( e ).to.eql( { own1: 'own1' , own2: 'own2' } ) ;\n\n// with 'proto', function exists if there are in the prototype\ne = extend( { nofunc: true , proto: true } , null , o ) ;\nexpect( e ).not.to.be( o ) ;\nexpect( e.__proto__ ).to.equal( proto ) ;\t// jshint ignore:line\nexpect( e ).to.eql( { own1: 'own1' , own2: 'own2' } ) ;\nexpect( e.proto1 ).to.be( 'proto1' ) ;\nexpect( e.proto2 ).to.be( 'proto2' ) ;\nexpect( typeof e.hello ).to.equal( 'function' ) ;\n```\n\nwith 'preserve' option should not overwrite existing properties in the target.\n\n```js\nvar e , o ;\n\ne = {\n\tone: '1' ,\n\ttwo: 2 ,\n\tthree: 'THREE'\n} ;\n\no = {\n\tthree: 3 ,\n\tfour: '4'\n} ;\n\nextend( { preserve: true } , e , o ) ;\nexpect( e ).to.eql( { one: '1' , two: 2 , three: 'THREE' , four: '4' } ) ;\nexpect( o ).to.eql( { three: 3 , four: '4' } ) ;\n```\n\nwith 'move' option should move source properties to target properties, i.e. delete them form the source.\n\n```js\nvar e , o ;\n\ne = {\n\tone: '1' ,\n\ttwo: 2 ,\n\tthree: 'THREE'\n} ;\n\no = {\n\tthree: 3 ,\n\tfour: '4'\n} ;\n\nextend( { move: true } , e , o ) ;\nexpect( e ).to.eql( { one: '1' , two: 2 , three: 3 , four: '4' } ) ;\nexpect( o ).to.eql( {} ) ;\n```\n\nwith 'preserve' and 'move' option should not overwrite existing properties in the target, so it should not move/delete them from the source object.\n\n```js\nvar e , o ;\n\ne = {\n\tone: '1' ,\n\ttwo: 2 ,\n\tthree: 'THREE'\n} ;\n\no = {\n\tthree: 3 ,\n\tfour: '4'\n} ;\n\nextend( { preserve: true , move: true } , e , o ) ;\nexpect( e ).to.eql( { one: '1' , two: 2 , three: 'THREE' , four: '4' } ) ;\nexpect( o ).to.eql( { three: 3 } ) ;\n```\n\nwith 'inherit' option should inherit rather than extend: each source property create a new Object or mutate existing Object into the related target property, using itself as the prototype.\n\n```js\nvar e , o ;\n\no = {\n\tthree: 3 ,\n\tfour: '4' ,\n\tsubtree: {\n\t\tfive: 'FIVE' ,\n\t\tsix: 6\n\t}\n} ;\n\ne = {} ;\n\nextend( { inherit: true } , e , o ) ;\n\nexpect( e.__proto__ ).to.equal( o ) ;\t// jshint ignore:line\nexpect( e ).to.eql( {} ) ;\nexpect( e.three ).to.be( 3 ) ;\nexpect( e.four ).to.be( '4' ) ;\nexpect( e.subtree ).to.equal( o.subtree ) ;\n\n\ne = {\n\tone: '1' ,\n\ttwo: 2 ,\n\tthree: 'THREE' ,\n} ;\n\nextend( { inherit: true } , e , o ) ;\n\nexpect( e.__proto__ ).to.equal( o ) ;\t// jshint ignore:line\nexpect( e ).to.eql( { one: '1' , two: 2 , three: 'THREE' } ) ;\nexpect( e.three ).to.be( 'THREE' ) ;\nexpect( e.four ).to.be( '4' ) ;\nexpect( e.subtree ).to.equal( o.subtree ) ;\t// jshint ignore:line\nexpect( e.subtree ).to.eql( { five: 'FIVE' , six: 6 } ) ;\n\n\ne = {\n\tone: '1' ,\n\ttwo: 2 ,\n\tthree: 'THREE' ,\n\tsubtree: {\n\t\tsix: 'SIX' ,\n\t\tseven: 7\n\t}\n} ;\n\nextend( { inherit: true } , e , o ) ;\n\nexpect( e.__proto__ ).to.equal( o ) ;\t// jshint ignore:line\nexpect( e ).to.eql( { one: '1' , two: 2 , three: 'THREE' , subtree: { six: 'SIX' , seven: 7 } } ) ;\nexpect( e.three ).to.be( 'THREE' ) ;\nexpect( e.four ).to.be( '4' ) ;\nexpect( e.subtree ).to.eql( { six: 'SIX' , seven: 7 } ) ;\nexpect( e.subtree.five ).to.equal( undefined ) ;\n```\n\nwith 'inherit' and 'deep' option should inherit recursively.\n\n```js\nvar e , o ;\n\no = {\n\tthree: 3 ,\n\tfour: '4' ,\n\tsubtree: {\n\t\tfive: 'FIVE' ,\n\t\tsix: 6\n\t}\n} ;\n\ne = {} ;\n\nextend( { inherit: true , deep: true } , e , o ) ;\n\nexpect( e.__proto__ ).to.equal( o ) ;\t// jshint ignore:line\nexpect( e ).to.eql( { subtree: {} } ) ;\nexpect( e.three ).to.be( 3 ) ;\nexpect( e.four ).to.be( '4' ) ;\nexpect( e.subtree.__proto__ ).to.equal( o.subtree ) ;\t// jshint ignore:line\nexpect( e.subtree.five ).to.equal( 'FIVE' ) ;\nexpect( e.subtree.six ).to.equal( 6 ) ;\n\n\ne = {\n\tone: '1' ,\n\ttwo: 2 ,\n\tthree: 'THREE' ,\n} ;\n\nextend( { inherit: true , deep: true } , e , o ) ;\n\nexpect( e.__proto__ ).to.equal( o ) ;\t// jshint ignore:line\nexpect( e ).to.eql( { one: '1' , two: 2 , three: 'THREE' , subtree: {} } ) ;\nexpect( e.three ).to.be( 'THREE' ) ;\nexpect( e.four ).to.be( '4' ) ;\nexpect( e.subtree.__proto__ ).to.equal( o.subtree ) ;\t// jshint ignore:line\nexpect( e.subtree ).to.eql( {} ) ;\nexpect( e.subtree.five ).to.equal( 'FIVE' ) ;\nexpect( e.subtree.six ).to.equal( 6 ) ;\n\n\ne = {\n\tone: '1' ,\n\ttwo: 2 ,\n\tthree: 'THREE' ,\n\tsubtree: {\n\t\tsix: 'SIX' ,\n\t\tseven: 7\n\t}\n} ;\n\nextend( { inherit: true , deep: true } , e , o ) ;\n\nexpect( e.__proto__ ).to.equal( o ) ;\t// jshint ignore:line\nexpect( e ).to.eql( { one: '1' , two: 2 , three: 'THREE' , subtree: { six: 'SIX' , seven: 7 } } ) ;\nexpect( e.three ).to.be( 'THREE' ) ;\nexpect( e.four ).to.be( '4' ) ;\nexpect( e.subtree.__proto__ ).to.equal( o.subtree ) ;\t// jshint ignore:line\nexpect( e.subtree ).to.eql( { six: 'SIX' , seven: 7 } ) ;\nexpect( e.subtree.five ).to.equal( 'FIVE' ) ;\n```\n\nwith 'flat' option.\n\n```js\nvar e , o ;\n\no = {\n\tthree: 3 ,\n\tfour: '4' ,\n\tsubtree: {\n\t\tfive: 'FIVE' ,\n\t\tsix: 6 ,\n\t\tsubsubtree: {\n\t\t\tsubsubsubtree: { one: 'ONE' } ,\n\t\t\tseven: 'seven'\n\t\t} ,\n\t\temptysubtree: {}\n\t} ,\n\teight: 8 ,\n\tanothersubtree: {\n\t\tnine: '9'\n\t}\n} ;\n\ne = extend( { flat: true } , {} , o ) ;\nexpect( e ).to.eql( {\n\tthree: 3 ,\n\tfour: '4' ,\n\t'subtree.five': 'FIVE' ,\n\t'subtree.six': 6 ,\n\t'subtree.subsubtree.seven': 'seven' ,\n\t'subtree.subsubtree.subsubsubtree.one': 'ONE' ,\n\teight: 8 ,\n\t'anothersubtree.nine': '9'\n} ) ;\n\ne = extend( { flat: '/' } , {} , o ) ;\nexpect( e ).to.eql( {\n\tthree: 3 ,\n\tfour: '4' ,\n\t'subtree/five': 'FIVE' ,\n\t'subtree/six': 6 ,\n\t'subtree/subsubtree/seven': 'seven' ,\n\t'subtree/subsubtree/subsubsubtree/one': 'ONE' ,\n\teight: 8 ,\n\t'anothersubtree/nine': '9'\n} ) ;\n```\n\nwith 'unflat' option.\n\n```js\nvar e , o ;\n\no = {\n\tthree: 3 ,\n\tfour: '4' ,\n\t'subtree.five': 'FIVE' ,\n\t'subtree.six': 6 ,\n\t'subtree.subsubtree.seven': 'seven' ,\n\t'subtree.subsubtree.subsubsubtree.one': 'ONE' ,\n\teight: 8 ,\n\t'anothersubtree.nine': '9'\n} ;\n\ne = extend( { unflat: true } , {} , o ) ;\nexpect( e ).to.eql( {\n\tthree: 3 ,\n\tfour: '4' ,\n\tsubtree: {\n\t\tfive: 'FIVE' ,\n\t\tsix: 6 ,\n\t\tsubsubtree: {\n\t\t\tsubsubsubtree: { one: 'ONE' } ,\n\t\t\tseven: 'seven'\n\t\t}\n\t} ,\n\teight: 8 ,\n\tanothersubtree: {\n\t\tnine: '9'\n\t}\n} ) ;\n\no = {\n\tthree: 3 ,\n\tfour: '4' ,\n\t'subtree/five': 'FIVE' ,\n\t'subtree/six': 6 ,\n\t'subtree/subsubtree/seven': 'seven' ,\n\t'subtree/subsubtree/subsubsubtree/one': 'ONE' ,\n\teight: 8 ,\n\t'anothersubtree/nine': '9'\n} ;\n\ne = extend( { unflat: '/' } , {} , o ) ;\nexpect( e ).to.eql( {\n\tthree: 3 ,\n\tfour: '4' ,\n\tsubtree: {\n\t\tfive: 'FIVE' ,\n\t\tsix: 6 ,\n\t\tsubsubtree: {\n\t\t\tsubsubsubtree: { one: 'ONE' } ,\n\t\t\tseven: 'seven'\n\t\t}\n\t} ,\n\teight: 8 ,\n\tanothersubtree: {\n\t\tnine: '9'\n\t}\n} ) ;\n```\n\nwith 'deepFilter' option, using blacklist.\n\n```js\nvar buf = new Buffer( \"My buffer\" ) ;\n\nvar o = {\n\tone: '1' ,\n\tbuf: buf ,\n\tsubtree: {\n\t\ttwo: 2 ,\n\t\tthree: 'THREE'\n\t}\n} ;\n\nvar e = extend( { deep: true, deepFilter: { blacklist: [ Buffer.prototype ] } } , {} , o ) ;\n\no.subtree.three = 3 ;\nbuf[ 0 ] = 'm'.charCodeAt() ;\n\nexpect( e.buf ).to.be.a( Buffer ) ;\nexpect( e.buf.toString() ).to.be( \"my buffer\" ) ;\nexpect( e.buf ).to.be( buf ) ;\n\nexpect( e ).to.eql( {\n\tone: '1' ,\n\tbuf: buf ,\n\tsubtree: {\n\t\ttwo: 2 ,\n\t\tthree: 'THREE'\n\t}\n} ) ;\n```\n\nwith 'deepFilter' option, using whitelist.\n\n```js\nvar buf = new Buffer( \"My buffer\" ) ;\n\nvar o = {\n\tone: '1' ,\n\tbuf: buf ,\n\tsubtree: {\n\t\ttwo: 2 ,\n\t\tthree: 'THREE'\n\t}\n} ;\n\nvar e = extend( { deep: true, deepFilter: { whitelist: [ Object.prototype ] } } , {} , o ) ;\n\no.subtree.three = 3 ;\nbuf[ 0 ] = 'm'.charCodeAt() ;\n\nexpect( e.buf ).to.be.a( Buffer ) ;\nexpect( e.buf.toString() ).to.be( \"my buffer\" ) ;\nexpect( e.buf ).to.be( buf ) ;\n\nexpect( e ).to.eql( {\n\tone: '1' ,\n\tbuf: buf ,\n\tsubtree: {\n\t\ttwo: 2 ,\n\t\tthree: 'THREE'\n\t}\n} ) ;\n```\n\ncircular references test.\n\n```js\nvar c , o = {\n\ta: 'a',\n\tsub: {\n\t\tb: 'b'\n\t},\n\tsub2: {\n\t\tc: 'c'\n\t}\n} ;\n\no.loop = o ;\no.sub.loop = o ;\no.subcopy = o.sub ;\no.sub.link = o.sub2 ;\no.sub2.link = o.sub ;\n\n\ntry {\n\tc = extend( { deep: true } , null , o ) ;\n\tthrow new Error( 'Should throw an error: max depth reached' ) ;\n}\ncatch ( error ) {\n}\n\nc = extend( { deep: true , circular: true } , null , o ) ;\n\nexpect( c.loop ).to.be( c ) ;\nexpect( c.sub ).to.be( c.subcopy ) ;\nexpect( c.sub.loop ).to.be( c ) ;\nexpect( c.subcopy.loop ).to.be( c ) ;\nexpect( c.sub.link ).to.be( c.sub2 ) ;\nexpect( c.sub2.link ).to.be( c.sub ) ;\n```\n\n<a name=\"definelazyproperty\"></a>\n# defineLazyProperty()\nshould define property using a getter that after its first execution is reconfigured as its return-value and is not writable.\n\n```js\nvar object = {} ;\nvar counter = 0 ;\n\ntree.defineLazyProperty( object , 'myprop' , function() {\n\tcounter ++ ;\n\treturn counter ;\n} ) ;\n\nexpect( object.myprop ).to.be( 1 ) ;\nexpect( object.myprop ).to.be( 1 ) ;\nexpect( object.myprop ).to.be( 1 ) ;\nexpect( counter ).to.be( 1 ) ;\nexpect( function() { object.myprop ++ ; } ).to.throwError() ;\nexpect( object.myprop ).to.be( 1 ) ;\n```\n\n<a name=\"masks\"></a>\n# Masks\nshould apply a simple mask tree to the input tree.\n\n```js\nvar mask = tree.createMask( {\n\tint: true,\n\tfloat: true,\n\tattachement: {\n\t\tfilename: true,\n\t\tunexistant: true\n\t},\n\tunexistant: true,\n\tsubtree: {\n\t\tsubtree: true\n\t}\n} ) ;\n\nvar output = mask.applyTo( input ) ;\n\nexpect( output ).to.eql( {\n\tint: 12,\n\tfloat: 2.47,\n\tattachement: {\n\t\tfilename: 'preview.png'\n\t},\n\tsubtree: {\n\t\tsubtree: {\n\t\t\td: 4,\n\t\t\te: undefined,\n\t\t\tf: 3.14\n\t\t}\n\t}\n} ) ;\n```\n\nshould apply a mask tree with wildcard '*' to the input tree.\n\n```js\nvar mask = tree.createMask( {\n\t'files': {\n\t\t'*': {\n\t\t\tsize: true,\n\t\t\tunexistant: true\n\t\t}\n\t}\n} ) ;\n\nvar output = mask.applyTo( input ) ;\n\nexpect( output.files ).to.be.an( Object ) ;\nexpect( output ).to.eql( {\n\tfiles: {\n\t\t'background.png' : {\n\t\t\tsize : '97856'\n\t\t} ,\n\t\t'header.png' : {\n\t\t\tsize : '44193'\n\t\t} ,\n\t\t'footer.png' : {\n\t\t\tsize : '36411'\n\t\t}\n\t}\n} ) ;\n```\n\nshould apply a mask tree with wildcard '*' to match array in the input tree.\n\n```js\nvar mask = tree.createMask( {\n\t'filesArray': {\n\t\t'*': {\n\t\t\tname: true,\n\t\t\tsize: true,\n\t\t\tunexistant: true\n\t\t}\n\t}\n} ) ;\n\nvar output = mask.applyTo( input ) ;\n\nexpect( output.filesArray ).to.be.an( Array ) ;\nexpect( output ).to.eql( {\n\tfilesArray: [\n\t\t{\n\t\t\tname : 'background.png' ,\n\t\t\tsize : '97856'\n\t\t} ,\n\t\t{\n\t\t\tname : 'header.png' ,\n\t\t\tsize : '44193'\n\t\t} ,\n\t\t{\n\t\t\tname : 'footer.png' ,\n\t\t\tsize : '36411'\n\t\t}\n\t]\n} ) ;\n\n//console.log( \"\\n\\n\\n\\n\" , output , \"\\n\\n\\n\\n\" ) ;\n```\n\nshould apply a mask with a mask's leaf callback to the input tree.\n\n```js\nvar leaf = function leaf( input , key , argument , path ) {\n\t//console.log( 'LEAF: ' , input , key , argument , path ) ;\n\t\n\tif ( ! input.hasOwnProperty( key ) ) { return new Error( 'not_found' ) ; }\n\tif ( typeof input[ key ] === 'number' ) { return input[ key ] + argument ; }\n\treturn input[ key ] ;\n} ;\n\nvar mask = tree.createMask(\n\t{\n\t\tint: 87 ,\n\t\tfloat: 14 ,\n\t\tsubtree: {\n\t\t\tsubtree: {\n\t\t\t\tf: 0.0016\n\t\t\t}\n\t\t} ,\n\t\tunexistant: 45\n\t} ,\n\t{ leaf: leaf }\n) ;\n\nvar output = mask.applyTo( input ) ;\n\nexpect( output ).to.eql( {\n\tint: 99,\n\tfloat: 16.47,\n\tsubtree: {\n\t\tsubtree: {\n\t\t\tf: 3.1416\n\t\t}\n\t}\n} ) ;\n```\n\nshould apply a mask containing other masks to the input tree.\n\n```js\nvar mask = tree.createMask( {\n\tint: true,\n\tfloat: true,\n\tattachement: tree.createMask( {\n\t\tfilename: true,\n\t\tunexistant: true\n\t} ),\n\tunexistant: true,\n\tsubtree: tree.createMask( {\n\t\tsubtree: true\n\t} )\n} ) ;\n\nvar output = mask.applyTo( input ) ;\n\nexpect( output ).to.eql( {\n\tint: 12,\n\tfloat: 2.47,\n\tattachement: {\n\t\tfilename: 'preview.png'\n\t},\n\tsubtree: {\n\t\tsubtree: {\n\t\t\td: 4,\n\t\t\te: undefined,\n\t\t\tf: 3.14\n\t\t}\n\t}\n} ) ;\n```\n\n<a name=\"inverse-masks\"></a>\n# Inverse masks\nshould apply a simple mask tree to the input tree.\n\n```js\nvar mask = tree.createInverseMask( {\n\ta: true,\n\tsubtree: {\n\t\td: true\n\t},\n\tsubtree2: true\n} ) ;\n\nvar output = mask.applyTo( input.subtree ) ;\n\n//console.log( output ) ;\n\nexpect( output ).to.eql( {\n\tb: 2,\n\tsubtree: {\n\t\te: undefined,\n\t\tf: 3.14\n\t},\n\tc: 'plusplus'\n} ) ;\n```\n\n<a name=\"trees-path-on-objects\"></a>\n# Tree's path on objects\npath.get() on object structure.\n\n```js\nvar o = {\n\ta: 5 ,\n\tsub: {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null\n} ;\n\nexpect( tree.path.get( o , 'a' ) ).to.be( 5 ) ;\nexpect( tree.path.get( o , 'sub' ) ).to.eql( {\n\tb: \"toto\" ,\n\tsub: {\n\t\tc: true\n\t}\n} ) ;\nexpect( tree.path.get( o , 'sub.b' ) ).to.be( \"toto\" ) ;\nexpect( tree.path.get( o , 'sub.sub' ) ).to.eql( { c: true } ) ;\nexpect( tree.path.get( o , 'sub.sub.c' ) ).to.be( true ) ;\nexpect( tree.path.get( o , 'd' ) ).to.be( null ) ;\nexpect( tree.path.get( o , 'nothing' ) ).to.be( undefined ) ;\nexpect( tree.path.get( o , 'sub.nothing' ) ).to.be( undefined ) ;\nexpect( tree.path.get( o , 'nothing.nothing' ) ).to.be( undefined ) ;\n```\n\npath.delete() on object structure.\n\n```js\nvar o = {\n\ta: 5 ,\n\tsub: {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true ,\n\t\t\tsub: {\n\t\t\t\tf: ''\n\t\t\t}\n\t\t}\n\t} ,\n\td: null\n} ;\n\ntree.path.delete( o , 'a' ) ;\ntree.path.delete( o , 'sub.sub' ) ;\ntree.path.delete( o , 'non.existant.path' ) ;\n\nexpect( o ).to.eql( {\n\tsub: {\n\t\tb: \"toto\" ,\n\t} ,\n\td: null\n} ) ;\n```\n\npath.set() on object structure.\n\n```js\nvar o = {\n\ta: 5 ,\n\tsub: {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null\n} ;\n\ntree.path.set( o , 'a' , \"8\" ) ;\ntree.path.set( o , 'sub.b' , false ) ;\ntree.path.set( o , 'sub.sub' , { x: 18 , y: 27 } ) ;\ntree.path.set( o , 'non.existant.path' , 'new' ) ;\n\nexpect( o ).to.eql( {\n\ta: \"8\" ,\n\tsub: {\n\t\tb: false ,\n\t\tsub: {\n\t\t\tx: 18 ,\n\t\t\ty: 27\n\t\t}\n\t} ,\n\td: null ,\n\tnon: {\n\t\texistant: {\n\t\t\tpath: 'new'\n\t\t}\n\t}\n} ) ;\n```\n\npath.define() on object structure.\n\n```js\nvar o = {\n\ta: 5 ,\n\tsub: {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null\n} ;\n\ntree.path.define( o , 'a' , \"8\" ) ;\ntree.path.define( o , 'sub.b' , false ) ;\ntree.path.define( o , 'unexistant' , '!' ) ;\ntree.path.define( o , 'sub.sub' , { x: 18 , y: 27 } ) ;\ntree.path.define( o , 'non.existant.path' , 'new' ) ;\n\nexpect( o ).to.eql( {\n\ta: 5 ,\n\tunexistant: '!' ,\n\tsub: {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null ,\n\tnon: {\n\t\texistant: {\n\t\t\tpath: 'new'\n\t\t}\n\t}\n} ) ;\n```\n\npath.inc() and path.dec() on object structure.\n\n```js\nvar o = {\n\ta: 5 ,\n\tsub: {\n\t\tb: 10 ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null\n} ;\n\ntree.path.inc( o , 'a' ) ;\ntree.path.dec( o , 'sub.b' ) ;\ntree.path.inc( o , 'sub' ) ;\ntree.path.dec( o , 'sub.sub' ) ;\ntree.path.inc( o , 'non.existant.path' ) ;\ntree.path.dec( o , 'another.non.existant.path' ) ;\n\nexpect( o ).to.eql( {\n\ta: 6 ,\n\tsub: {\n\t\tb: 9 ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null ,\n\tnon: {\n\t\texistant: {\n\t\t\tpath: 1\n\t\t}\n\t} ,\n\tanother: {\n\t\tnon: {\n\t\t\texistant: {\n\t\t\t\tpath: -1\n\t\t\t}\n\t\t}\n\t}\n} ) ;\n```\n\npath.append() and path.prepend() on object structure.\n\n```js\nvar o = {\n\ta: null ,\n\tsub: {\n\t\tb: [ 'some' ] ,\n\t\tsub: {\n\t\t\tc: [ 'value' ]\n\t\t}\n\t} ,\n} ;\n\ntree.path.append( o , 'a' , 'hello' ) ;\ntree.path.append( o , 'sub.b' , 'value' ) ;\ntree.path.prepend( o , 'sub.sub.c' , 'other' ) ;\ntree.path.prepend( o , 'sub.sub.c' , 'some' ) ;\ntree.path.append( o , 'sub.sub.c' , '!' ) ;\ntree.path.append( o , 'non.existant.path' , '!' ) ;\ntree.path.prepend( o , 'another.non.existant.path' , '!' ) ;\n\nexpect( o ).to.eql( {\n\ta: [ 'hello' ] ,\n\tsub: {\n\t\tb: [ 'some' , 'value' ] ,\n\t\tsub: {\n\t\t\tc: [ 'some' , 'other' , 'value' , '!' ]\n\t\t}\n\t} ,\n\tnon: {\n\t\texistant: {\n\t\t\tpath: [ '!' ]\n\t\t}\n\t} ,\n\tanother: {\n\t\tnon: {\n\t\t\texistant: {\n\t\t\t\tpath: [ '!' ]\n\t\t\t}\n\t\t}\n\t}\n} ) ;\n```\n\npath.concat() and path.insert() on object structure.\n\n```js\nvar o = {\n\ta: null ,\n\tsub: {\n\t\tb: [ 'hi' ] ,\n\t\tsub: {\n\t\t\tc: [ 'again' ]\n\t\t}\n\t} ,\n} ;\n\ntree.path.concat( o , 'a' , [ 'hello' , 'world' ] ) ;\ntree.path.concat( o , 'sub.b' , [ 'hello' , 'world' ] ) ;\ntree.path.insert( o , 'sub.sub.c' , [ 'hello' , 'world' ] ) ;\n\nexpect( o ).to.eql( {\n\ta: [ 'hello' , 'world' ] ,\n\tsub: {\n\t\tb: [ 'hi' , 'hello' , 'world' ] ,\n\t\tsub: {\n\t\t\tc: [ 'hello' , 'world' , 'again' ]\n\t\t}\n\t}\n} ) ;\n```\n\npath.autoPush().\n\n```js\nvar o = {\n\ta: 1 ,\n\tsub: {\n\t\tb: [ 'some' ] ,\n\t\tsub: {\n\t\t\tc: [ 'some' , 'other' , 'value' ]\n\t\t}\n\t} ,\n} ;\n\ntree.path.autoPush( o , 'a' , 'hello' ) ;\ntree.path.autoPush( o , 'd' , 'D' ) ;\ntree.path.autoPush( o , 'sub.b' , 'value' ) ;\ntree.path.autoPush( o , 'sub.sub.c' , '!' ) ;\ntree.path.autoPush( o , 'non.existant.path' , '!' ) ;\n\nexpect( o ).to.eql( {\n\ta: [ 1 , 'hello' ] ,\n\td: 'D' ,\n\tsub: {\n\t\tb: [ 'some' , 'value' ] ,\n\t\tsub: {\n\t\t\tc: [ 'some' , 'other' , 'value' , '!' ]\n\t\t}\n\t} ,\n\tnon: {\n\t\texistant: {\n\t\t\tpath: '!'\n\t\t}\n\t}\n} ) ;\n```\n\nempty keys.\n\n```js\nvar o ;\n\no = {\n\ta: 5 ,\n\t\"\": {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null\n} ;\n\nexpect( tree.path.get( o , 'a' ) ).to.be( 5 ) ;\nexpect( tree.path.get( o , '' ) ).to.eql( { b: \"toto\" , sub: { c: true } } ) ;\nexpect( tree.path.get( o , '.b' ) ).to.be( \"toto\" ) ;\nexpect( tree.path.get( o , '.sub' ) ).to.eql( { c: true } ) ;\nexpect( tree.path.get( o , '.sub.c' ) ).to.be( true ) ;\n\no = {\n\t\"\": {\n\t\t\"\": {\n\t\t\t\"\": {\n\t\t\t\ta: 1 ,\n\t\t\t\tb: 2\n\t\t\t}\n\t\t}\n\t} ,\n} ;\n\nexpect( tree.path.get( o , '' ) ).to.eql( { \"\": { \"\": { a: 1 , b: 2 } } } ) ;\nexpect( tree.path.get( o , '.' ) ).to.eql( { \"\": { a: 1 , b: 2 } } ) ;\nexpect( tree.path.get( o , '..' ) ).to.eql( { a: 1 , b: 2 } ) ;\nexpect( tree.path.get( o , '...a' ) ).to.eql( 1 ) ;\n```\n\n<a name=\"trees-path-on-arrays\"></a>\n# Tree's path on arrays\npath.get() on a simple array.\n\n```js\nvar a = [ 'a' , 'b' , 'c' ] ;\n\nexpect( tree.path.get( a , '0' ) ).to.be( 'a' ) ;\nexpect( tree.path.get( a , '1' ) ).to.be( 'b' ) ;\nexpect( tree.path.get( a , '2' ) ).to.be( 'c' ) ;\nexpect( tree.path.get( a , '3' ) ).to.be( undefined ) ;\nexpect( tree.path.get( a , '#0' ) ).to.be( 'a' ) ;\nexpect( tree.path.get( a , '#1' ) ).to.be( 'b' ) ;\nexpect( tree.path.get( a , '#2' ) ).to.be( 'c' ) ;\nexpect( tree.path.get( a , '#3' ) ).to.be( undefined ) ;\nexpect( tree.path.get( a , '[0]' ) ).to.be( 'a' ) ;\nexpect( tree.path.get( a , '[1]' ) ).to.be( 'b' ) ;\nexpect( tree.path.get( a , '[2]' ) ).to.be( 'c' ) ;\nexpect( tree.path.get( a , '[3]' ) ).to.be( undefined ) ;\nexpect( tree.path.get( a , 'length' ) ).to.be( 3 ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 3 ) ;\nexpect( tree.path.get( a , 'first' ) ).to.be( undefined ) ;\nexpect( tree.path.get( a , '#first' ) ).to.be( 'a' ) ;\nexpect( tree.path.get( a , 'last' ) ).to.be( undefined ) ;\nexpect( tree.path.get( a , '#last' ) ).to.be( 'c' ) ;\nexpect( tree.path.get( a , 'next' ) ).to.be( undefined ) ;\nexpect( tree.path.get( a , '#next' ) ).to.be( undefined ) ;\n```\n\npath.get() on nested arrays.\n\n```js\nvar a = [ 'a' , [ [ 'b' , 'c' ] , 'd' , [ 'e' , 'f' ] ] ] ;\n\nexpect( tree.path.get( a , '#0' ) ).to.be( 'a' ) ;\nexpect( tree.path.get( a , '#1' ) ).to.eql( [ [ 'b' , 'c' ] , 'd' , [ 'e' , 'f' ] ] ) ;\nexpect( tree.path.get( a , '#2' ) ).to.be( undefined ) ;\nexpect( tree.path.get( a , '[0]' ) ).to.be( 'a' ) ;\nexpect( tree.path.get( a , '[1]' ) ).to.eql( [ [ 'b' , 'c' ] , 'd' , [ 'e' , 'f' ] ] ) ;\nexpect( tree.path.get( a , '[2]' ) ).to.be( undefined ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 2 ) ;\nexpect( tree.path.get( a , '#first' ) ).to.be( 'a' ) ;\nexpect( tree.path.get( a , '#last' ) ).to.eql( [ [ 'b' , 'c' ] , 'd' , [ 'e' , 'f' ] ] ) ;\nexpect( tree.path.get( a , '#next' ) ).to.be( undefined ) ;\n\nexpect( tree.path.get( a , '1#0' ) ).to.eql( [ 'b' , 'c' ] ) ;\nexpect( tree.path.get( a , '1#1' ) ).to.eql( 'd' ) ;\nexpect( tree.path.get( a , '1#2' ) ).to.eql( [ 'e' , 'f' ] ) ;\nexpect( tree.path.get( a , '1#3' ) ).to.be( undefined ) ;\nexpect( tree.path.get( a , '[1][0]' ) ).to.eql( [ 'b' , 'c' ] ) ;\nexpect( tree.path.get( a , '[1][1]' ) ).to.eql( 'd' ) ;\nexpect( tree.path.get( a , '[1][2]' ) ).to.eql( [ 'e' , 'f' ] ) ;\nexpect( tree.path.get( a , '[1][3]' ) ).to.be( undefined ) ;\nexpect( tree.path.get( a , '1#length' ) ).to.be( 3 ) ;\nexpect( tree.path.get( a , '1#first' ) ).to.eql( [ 'b' , 'c' ] ) ;\nexpect( tree.path.get( a , '1#last' ) ).to.eql( [ 'e' , 'f' ] ) ;\nexpect( tree.path.get( a , '1#next' ) ).to.be( undefined ) ;\n\nexpect( tree.path.get( a , '1#2#last' ) ).to.eql( 'f' ) ;\n```\n\npath.set() on a simple array.\n\n```js\nvar a ;\n\na = [ 'a' , 'b' , 'c' ] ;\n\ntree.path.set( a , '1' , 'B' ) ;\ntree.path.set( a , '#last' , 3 ) ;\ntree.path.set( a , '#next' , 'D' ) ;\ntree.path.set( a , '#first' , 1 ) ;\n\nexpect( a ).to.eql( [ 1 , 'B' , 3 , 'D' ] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 4 ) ;\n\na = [ 'a' , 'b' , 'c' ] ;\n\ntree.path.set( a , '[1]' , 'BBB' ) ;\ntree.path.set( a , '#last' , 3 ) ;\ntree.path.set( a , '#next' , 'D' ) ;\ntree.path.set( a , '#first' , 1 ) ;\n\nexpect( a ).to.eql( [ 1 , 'BBB' , 3 , 'D' ] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 4 ) ;\n```\n\npath.set() using multiple #next and #insert.\n\n```js\nvar a = [ 'a' , 'b' , 'c' ] ;\n\ntree.path.set( a , '#next' , 'D' ) ;\ntree.path.set( a , '#next.f#next' , 'g' ) ;\ntree.path.set( a , '#next#next#next' , 'E' ) ;\ntree.path.set( a , '#insert' , '@' ) ;\ntree.path.set( a , '#last#insert' , '@' ) ;\n\nexpect( a ).to.eql( [ '@' , 'a' , 'b' , 'c' , 'D' ,  { f: [ 'g' ] } , [ '@' , [ 'E' ] ] ] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 7 ) ;\n```\n\npath.delete() on a simple array.\n\n```js\nvar a ;\n\na = [ 'a' , 'b' , 'c' ] ;\ntree.path.delete( a , '1' ) ;\n//expect( a ).to.eql( [ 'a' , undefined , 'c' ] ) ;\t// expect() bug here...\nexpect( tree.path.get( a , '#length' ) ).to.be( 3 ) ;\n\na = [ 'a' , 'b' , 'c' ] ;\ntree.path.delete( a , '#1' ) ;\nexpect( a ).to.eql( [ 'a' , 'c' ] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 2 ) ;\n\na = [ 'a' , 'b' , 'c' ] ;\ntree.path.delete( a , '[1]' ) ;\nexpect( a ).to.eql( [ 'a' , 'c' ] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 2 ) ;\n\na = [ 'a' , 'b' , 'c' ] ;\ntree.path.delete( a , '#2' ) ;\nexpect( a ).to.eql( [ 'a' , 'b' ] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 2 ) ;\n\na = [ 'a' , 'b' , 'c' ] ;\ntree.path.delete( a , '[2]' ) ;\nexpect( a ).to.eql( [ 'a' , 'b' ] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 2 ) ;\n\na = [ 'a' , 'b' , 'c' ] ;\ntree.path.delete( a , '#last' ) ;\nexpect( a ).to.eql( [ 'a' , 'b' ] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 2 ) ;\ntree.path.delete( a , '#last' ) ;\nexpect( a ).to.eql( [ 'a' ] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 1 ) ;\ntree.path.delete( a , '#last' ) ;\nexpect( a ).to.eql( [] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 0 ) ;\n\na = [ 'a' , 'b' , 'c' ] ;\ntree.path.delete( a , '#first' ) ;\nexpect( a ).to.eql( [ 'b' , 'c' ] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 2 ) ;\ntree.path.delete( a , '#first' ) ;\nexpect( a ).to.eql( [ 'c' ] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 1 ) ;\ntree.path.delete( a , '#first' ) ;\nexpect( a ).to.eql( [] ) ;\nexpect( tree.path.get( a , '#length' ) ).to.be( 0 ) ;\n```\n\n<a name=\"trees-path-on-mixed-object-and-arrays\"></a>\n# Tree's path on mixed object and arrays\npath.get() on a simple array.\n\n```js\nvar a = {\n\tmethod: 'get' ,\n\tpopulate: [ 'parents', 'godfather' ]\n} ;\n\nexpect( tree.path.get( a , 'method' ) ).to.be( 'get' ) ;\nexpect( tree.path.get( a , 'populate' ) ).to.eql( [ 'parents', 'godfather' ] ) ;\nexpect( tree.path.get( a , 'populate[0]' ) ).to.be( 'parents' ) ;\nexpect( tree.path.get( a , 'populate[1]' ) ).to.be( 'godfather' ) ;\nexpect( tree.path.get( a , 'populate[2]' ) ).to.be( undefined ) ;\n```\n\npath.set() on a simple array.\n\n```js\nvar a = {\n\tmethod: 'get' ,\n\tpopulate: [ 'parent', 'godfather' ]\n} ;\n\ntree.path.set( a , 'method' , 'post' ) ;\ntree.path.set( a , 'populate[0]' , 'friends' ) ;\nexpect( a ).to.eql( {\n\tmethod: 'post' ,\n\tpopulate: [ 'friends', 'godfather' ]\n} ) ;\n```\n\n<a name=\"inheritance-using-objectcreate-treepathprototype-\"></a>\n# Inheritance, using Object.create( tree.path.prototype )\n.get().\n\n```js\nvar o = Object.create( tree.path.prototype ) ;\n\no.a = 5 ;\no.sub = {\n\tb: \"toto\" ,\n\tsub: {\n\t\tc: true\n\t}\n} ;\no.d = null ;\n\nexpect( o.get( 'a' ) ).to.be( 5 ) ;\nexpect( o.get( 'sub' ) ).to.eql( {\n\tb: \"toto\" ,\n\tsub: {\n\t\tc: true\n\t}\n} ) ;\nexpect( o.get( 'sub.b' ) ).to.be( \"toto\" ) ;\nexpect( o.get( 'sub.sub' ) ).to.eql( { c: true } ) ;\nexpect( o.get( 'sub.sub.c' ) ).to.be( true ) ;\nexpect( o.get( 'd' ) ).to.be( null ) ;\nexpect( o.get( 'nothing' ) ).to.be( undefined ) ;\nexpect( o.get( 'sub.nothing' ) ).to.be( undefined ) ;\nexpect( o.get( 'nothing.nothing' ) ).to.be( undefined ) ;\n```\n\n.delete().\n\n```js\nvar o = Object.create( tree.path.prototype ) ;\n\no.a = 5 ;\no.sub = {\n\tb: \"toto\" ,\n\tsub: {\n\t\tc: true ,\n\t\tsub: {\n\t\t\tf: ''\n\t\t}\n\t}\n} ;\no.d = null ;\n\no.delete( 'a' ) ;\no.delete( 'sub.sub' ) ;\no.delete( 'non.existant.path' ) ;\n\nexpect( o ).to.eql( {\n\tsub: {\n\t\tb: \"toto\" ,\n\t} ,\n\td: null\n} ) ;\n```\n\n.set().\n\n```js\nvar o = Object.create( tree.path.prototype ) ;\n\no.a = 5 ;\no.sub = {\n\tb: \"toto\" ,\n\tsub: {\n\t\tc: true\n\t}\n} ;\no.d = null ;\n\no.set( 'a' , \"8\" ) ;\no.set( 'sub.b' , false ) ;\no.set( 'sub.sub' , { x: 18 , y: 27 } ) ;\no.set( 'non.existant.path' , 'new' ) ;\n\nexpect( o ).to.eql( {\n\ta: \"8\" ,\n\tsub: {\n\t\tb: false ,\n\t\tsub: {\n\t\t\tx: 18 ,\n\t\t\ty: 27\n\t\t}\n\t} ,\n\td: null ,\n\tnon: {\n\t\texistant: {\n\t\t\tpath: 'new'\n\t\t}\n\t}\n} ) ;\n```\n\n.define().\n\n```js\nvar o = Object.create( tree.path.prototype ) ;\n\no.a = 5 ;\no.sub = {\n\tb: \"toto\" ,\n\tsub: {\n\t\tc: true\n\t}\n} ;\no.d = null ;\n\no.define( 'a' , \"8\" ) ;\no.define( 'sub.b' , false ) ;\no.define( 'unexistant' , '!' ) ;\no.define( 'sub.sub' , { x: 18 , y: 27 } ) ;\no.define( 'non.existant.path' , 'new' ) ;\n\nexpect( o ).to.eql( {\n\ta: 5 ,\n\tunexistant: '!' ,\n\tsub: {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null ,\n\tnon: {\n\t\texistant: {\n\t\t\tpath: 'new'\n\t\t}\n\t}\n} ) ;\n```\n\n.inc() and .dec().\n\n```js\nvar o = Object.create( tree.path.prototype ) ;\n\no.a = 5 ;\no.sub = {\n\tb: 10 ,\n\tsub: {\n\t\tc: true\n\t}\n} ;\no.d = null ;\n\no.inc( 'a' ) ;\no.dec( 'sub.b' ) ;\no.inc( 'sub' ) ;\no.dec( 'sub.sub' ) ;\no.inc( 'non.existant.path' ) ;\no.dec( 'another.non.existant.path' ) ;\n\nexpect( o ).to.eql( {\n\ta: 6 ,\n\tsub: {\n\t\tb: 9 ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null ,\n\tnon: {\n\t\texistant: {\n\t\t\tpath: 1\n\t\t}\n\t} ,\n\tanother: {\n\t\tnon: {\n\t\t\texistant: {\n\t\t\t\tpath: -1\n\t\t\t}\n\t\t}\n\t}\n} ) ;\n```\n\n<a name=\"trees-array-path-on-objects\"></a>\n# Tree's array path on objects\npath.get() on object structure.\n\n```js\nvar o = {\n\ta: 5 ,\n\tsub: {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null\n} ;\n\nexpect( tree.path.get( o , [ 'a' ] ) ).to.be( 5 ) ;\nexpect( tree.path.get( o , [ 'sub' ] ) ).to.eql( {\n\tb: \"toto\" ,\n\tsub: {\n\t\tc: true\n\t}\n} ) ;\n\nexpect( tree.path.get( o , [ 'sub' , 'b' ] ) ).to.be( \"toto\" ) ;\nexpect( tree.path.get( o , [ 'sub' , 'sub' ] ) ).to.eql( { c: true } ) ;\nexpect( tree.path.get( o , [ 'sub' , 'sub' , 'c' ] ) ).to.be( true ) ;\nexpect( tree.path.get( o , [ 'd' ] ) ).to.be( null ) ;\nexpect( tree.path.get( o , [ 'nothing' ] ) ).to.be( undefined ) ;\nexpect( tree.path.get( o , [ 'sub' , 'nothing' ] ) ).to.be( undefined ) ;\nexpect( tree.path.get( o , [ 'nothing' , 'nothing' ] ) ).to.be( undefined ) ;\n```\n\npath.delete() on object structure.\n\n```js\nvar o = {\n\ta: 5 ,\n\tsub: {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true ,\n\t\t\tsub: {\n\t\t\t\tf: ''\n\t\t\t}\n\t\t}\n\t} ,\n\td: null\n} ;\n\ntree.path.delete( o , [ 'a' ] ) ;\ntree.path.delete( o , [ 'sub' , 'sub' ] ) ;\ntree.path.delete( o , [ 'non' , 'existant' , 'path' ] ) ;\n\nexpect( o ).to.eql( {\n\tsub: {\n\t\tb: \"toto\" ,\n\t} ,\n\td: null\n} ) ;\n```\n\npath.set() on object structure.\n\n```js\nvar o = {\n\ta: 5 ,\n\tsub: {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null\n} ;\n\ntree.path.set( o , [ 'a' ] , \"8\" ) ;\ntree.path.set( o , [ 'sub' , 'b' ] , false ) ;\ntree.path.set( o , [ 'sub' , 'sub' ] , { x: 18 , y: 27 } ) ;\ntree.path.set( o , [ 'non' , 'existant' , 'path' ] , 'new' ) ;\n\nexpect( o ).to.eql( {\n\ta: \"8\" ,\n\tsub: {\n\t\tb: false ,\n\t\tsub: {\n\t\t\tx: 18 ,\n\t\t\ty: 27\n\t\t}\n\t} ,\n\td: null ,\n\tnon: {\n\t\texistant: {\n\t\t\tpath: 'new'\n\t\t}\n\t}\n} ) ;\n```\n\npath.define() on object structure.\n\n```js\nvar o = {\n\ta: 5 ,\n\tsub: {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null\n} ;\n\ntree.path.define( o , [ 'a' ] , \"8\" ) ;\ntree.path.define( o , [ 'sub' , 'b' ] , false ) ;\ntree.path.define( o , [ 'unexistant' ] , '!' ) ;\ntree.path.define( o , [ 'sub' , 'sub' ] , { x: 18 , y: 27 } ) ;\ntree.path.define( o , [ 'non' , 'existant' , 'path' ] , 'new' ) ;\n\nexpect( o ).to.eql( {\n\ta: 5 ,\n\tunexistant: '!' ,\n\tsub: {\n\t\tb: \"toto\" ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null ,\n\tnon: {\n\t\texistant: {\n\t\t\tpath: 'new'\n\t\t}\n\t}\n} ) ;\n```\n\npath.inc() and path.dec() on object structure.\n\n```js\nvar o = {\n\ta: 5 ,\n\tsub: {\n\t\tb: 10 ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null\n} ;\n\ntree.path.inc( o , [ 'a' ] ) ;\ntree.path.dec( o , [ 'sub' , 'b' ] ) ;\ntree.path.inc( o , [ 'sub' ] ) ;\ntree.path.dec( o , [ 'sub' , 'sub' ] ) ;\ntree.path.inc( o , [ 'non' , 'existant' , 'path' ] ) ;\ntree.path.dec( o , [ 'another' , 'non' , 'existant' , 'path' ] ) ;\n\nexpect( o ).to.eql( {\n\ta: 6 ,\n\tsub: {\n\t\tb: 9 ,\n\t\tsub: {\n\t\t\tc: true\n\t\t}\n\t} ,\n\td: null ,\n\tnon: {\n\t\texistant: {\n\t\t\tpath: 1\n\t\t}\n\t} ,\n\tanother: {\n\t\tnon: {\n\t\t\texistant: {\n\t\t\t\tpath: -1\n\t\t\t}\n\t\t}\n\t}\n} ) ;\n```\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cronvel/tree-kit.git"
  },
  "scripts": {
    "test": "mocha -R dot"
  },
  "version": "0.5.26"
}
